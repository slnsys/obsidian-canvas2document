import { normalizePath, Workspace, WorkspaceLeaf, TFile, App, Editor, MarkdownView, Notice, Plugin, PluginSettingTab, Setting, FileSystemAdapter } from 'obsidian';
// import * as fs from 'fs';
import * as path from 'path';
// mytodo: path und filename/ext. detection mit interner API, nicht node.js etc.


// Remember to rename these classes and interfaces!

interface MyPluginSettings {
	mySetting: string;
}

const DEFAULT_SETTINGS: MyPluginSettings = {
	mySetting: 'default'
}

export default class Canvas2DocumentPlugin extends Plugin {
	settings: MyPluginSettings;
	fsadapter: FileSystemAdapter;

	async onload() {
		await this.loadSettings();
		this.fsadapter = this.app.vault.adapter as FileSystemAdapter;
	
		this.addCommand({
			id: "run-conversion",
			name: "Convert Canvas to a longform document",
			callback: async () => {
				const canvStruct = await this.readCanvasStruct();
				if (canvStruct == false) {
					new Notice(`this is not a canvas file`);
					return;
				}

				const contents = await this.readCanvasData(canvStruct);

				this.writeCanvDocFile(contents, canvStruct);

			},
		});
	
		// this.addSettingTab(new SampleSettingTab(this.app, this));

	}

	onunload() {
		// TODO cleaning up
	}

	async loadSettings() {
		this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
	}

	async saveSettings() {
		await this.saveData(this.settings);
	}


	async readCanvasStruct(): Promise<number> {
		/*
		check on active file is canvas
		*/
		let activeFile = this.app.workspace.getActiveFile();
		if (!activeFile || activeFile.extension != "canvas") {
			return false;
		} else {
			console.log("BASENAME: " + activeFile.basename);

			let mdFolderPath: string = path.dirname(activeFile.path);
			console.log("newpath: " + mdFolderPath)

		}

		// TODO: prevent reading all files, just the active file, if canvas check ok

		//let actcanvasfile = app.vault.getAbstractFileByPath(activeFile);
		let content = this.app.vault.cachedRead(activeFile);

		return content;
	}	


	async readCanvasData(struct): Promise<number> {

		// TODO: nochmal nach https://docs.obsidian.md/Plugins/Vault, read all files
		// input liste eben aus canvas-JSON alle nodes

		const fileContents: [string, string, string, string][] = [];

		var myparsed_data = JSON.parse(struct);

		for (const node of myparsed_data.nodes) {
			const id = node.id;
			const type = node.type;
			let nodefile = "";

			if (type === "file") {
				nodefile = node.file;
				const { name, ext } = path.parse(nodefile);

				// main file type markdown note
				if (ext === ".md") {
					fileContents.push([id, type, nodefile, "textfile"]);

				} else if (ext === ".jpg" || ext === ".png" || ext === ".gif") {
					fileContents.push([id, type, nodefile, "contentimage"]);
				} else if (ext === ".pdf") {
					fileContents.push([id, type, nodefile, "contentpdf"]);
				} else {
					console.log("unknown file type");
				}
			} else if (type === "link") {
				// check if node.url contains string "youtube" 
				if (node.url.includes("youtube")) {
					const url = node.url;
					fileContents.push([id, type, url, "contentyoutube"]);
				} else {
					fileContents.push([id, type, node.url, "contentlink"]);
				}
			} else if (type === "text") {
				const text = node.text;

				fileContents.push([id, type, "node", text]);
			}
		}

		return fileContents;
	}

	getNodes(id) {
		// get all nodes from the canvas file
		// return array of nodes
		return;
		
	}
	
	async writeCanvDocFile(content, convStruct) {
		// console.log(content);

		// establishing the workdir
		let activeFile = this.app.workspace.getActiveFile();
		let mdFolderPath: string = path.dirname(activeFile.path);

		let writeworkdir = mdFolderPath + "/" + activeFile.basename + "_canvas2doc-data"
		this.fsadapter.mkdir(writeworkdir)

		let canvasFile
	    let canvasFilename = mdFolderPath + "/" + activeFile.basename + "_" + Math.round(new Date().getTime()/1000) + "_fromCanvas.md"

		var contentString = "This is an automatically generated document generated by Plugin [Canvas2Document](https://google.de)\n\n"

		// var contentString = "";
		var myparsed_data = JSON.parse(convStruct);

		for (const element of content) {
			
			let cnfname = ""
			if (element[1] == "text") {
				
				cnfname = writeworkdir + "/" + "newdoc-node_" + element[0] + "_fromCanvas.md"
				
				// heading f端r navi links
				contentString += "\n\n# ___card from Canvas\n"

				// Filename und interner link anchor
				contentString += element[2] + " ^" + element[0] + "\n\n"

				// linking box
				contentString += "> [!tip] link navigation from the canvas\n"
				for (const edge of myparsed_data.edges) {
					if (edge.fromNode == element[0]) {
						contentString += "> linking to: [[#^" + edge.toNode + "|canvaslink]]\n"
					} 
					if (edge.toNode == element[0]) {
						contentString += "> linked from: [[#^" + edge.fromNode + "|canvaslink]]\n"
					} 
				}

				//Embedding
				contentString += "\n ![[" + cnfname + "]]\n\n"

			} else if (element[1] == "link") {
				// cnfname = writeworkdir + "/" + "newdoc-node_" + element[0] + " _fromCanvas.md"

				// heading f端r navi links
				contentString += "\n\n# ___link from Canvas\n"

				// Filename und interner link anchor
				contentString += element[2] + " ^" + element[0] + "\n\n"

				// linking box
				contentString += "> [!tip] link navigation from the canvas\n"
				for (const edge of myparsed_data.edges) {
					if (edge.fromNode == element[0]) {
						contentString += "> linking to: [[#^" + edge.toNode + "|canvaslink]]\n"
					} 
					if (edge.toNode == element[0]) {
						contentString += "> linked from: [[#^" + edge.fromNode + "|canvaslink]]\n"
					} 
				}

				//Embedding media specific
				if (element[3] == "contentyoutube") {
					contentString += "\n ![](" + element[2] + ")\n\n"
				} else if (element[3] == "contentlink") {
					contentString += "\n <iframe src=\"" + element[2] + "\"></iframe>\n\n"
				}

			} else if (element[1] == "file") {
				if (element[3] == "contentimage" || element[3] == "contentpdf") {

					// heading f端r navi links
					contentString += "\n\n# ___Media from Canvas\n"
				
					// starttag meta data block
					// contentString += "\n%%\ncanvas2document plugin metadata header start\n%%\n"

					// Filename und interner link anchor
					contentString += element[2] + " ^" + element[0] + "\n\n"

					// linking box
					// TODO linking box noch in funktion auslagern
					contentString += "> [!tip] link navigation from the canvas\n"
					for (const edge of myparsed_data.edges) {
						if (edge.fromNode == element[0]) {
							contentString += "> linking to: [[#^" + edge.toNode + "|canvaslink]]\n"
						} 
						if (edge.toNode == element[0]) {
							contentString += "> linked from: [[#^" + edge.fromNode + "|canvaslink]]\n"
						} 
					}
					// starttag meta data block
					// contentString += "\n%%\ncanvas2document plugin metadata header end\n%%\n"
				
					//Embedding media specific
					if (element[3] == "contentpdf") {
						contentString += "\n ![[" + element[2] + "#height=500]]\n\n"
					} else if (element[3] == "contentimage") {
						contentString += "\n ![[" + element[2] + "|500]]\n\n"
					}				

				} else {
					
					// heading f端r navi links
					contentString += "\n\n# ___noteFile from Canvas\n"
				
					// Filename und interner link anchor
					contentString += element[2] + " ^" + element[0] + "\n\n"

					// linking box
					contentString += "> [!tip] link navigation from the canvas\n"
					for (const edge of myparsed_data.edges) {
						if (edge.fromNode == element[0]) {
							contentString += "> linking to: [[#^" + edge.toNode + "|canvaslink]]\n"
						} 
						if (edge.toNode == element[0]) {
							contentString += "> linked from: [[#^" + edge.fromNode + "|canvaslink]]\n"
						} 
					}
				
					// Embedding
					contentString += "\n ![[" +  element[2] + "]]\n\n"

				}
			}

			let canvasnodeFile

			try {
				let cnfabst = this.app.vault.getAbstractFileByPath(cnfname);
				this.app.vault.delete(cnfabst, true)
				canvasnodeFile = this.app.vault.create(cnfname, element[3])
			} catch (e) {
				console.log(e)
				return
			}	

		}

   	    try {
	      canvasFile = await this.app.vault.create(canvasFilename, contentString)
	    } catch (e) {
			console.log("error writing the new doc file " + e)
		}

		const cnfabst = await this.app.vault.getAbstractFileByPath(canvasFilename);
		
		try {
			await this.app.workspace.getLeaf('split').openFile(cnfabst);
		} catch (e) {
			console.log(e)
		}
		return

	}
}

// class SampleSettingTab extends PluginSettingTab {
// 	plugin: Canvas2DocumentPlugin;

// 	constructor(app: App, plugin: Canvas2DocumentPlugin) {
// 		super(app, plugin);
// 		this.plugin = plugin;
// 	}

// 	display(): void {
// 		const {containerEl} = this;

// 		containerEl.empty();

// 		new Setting(containerEl)
// 			.setName('Setting #1')
// 			.setDesc('It\'s a secret')
// 			.addText(text => text
// 				.setPlaceholder('Enter your secret')
// 				.setValue(this.plugin.settings.mySetting)
// 				.onChange(async (value) => {
// 					this.plugin.settings.mySetting = value;
// 					await this.plugin.saveSettings();
// 				}));
// 	}
// }
